<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>7.2 Rc&lt;T&gt;とArc&lt;T&gt; - Rust入門</title>
</head>
<body>
<p><a href="index.html">目次に戻る</a></p>
<h1>7.2 Rc&lt;T&gt;とArc&lt;T&gt;</h1>

<h2>C++との比較</h2>
<table border="1" cellpadding="5">
<tr><th>Rust</th><th>C++相当</th><th>用途</th></tr>
<tr><td>Rc&lt;T&gt;</td><td>shared_ptr（シングルスレッド）</td><td>共有所有権（非スレッドセーフ）</td></tr>
<tr><td>Arc&lt;T&gt;</td><td>shared_ptr（スレッドセーフ）</td><td>共有所有権（スレッドセーフ）</td></tr>
</table>

<h2>Rc&lt;T&gt;（Reference Counted）</h2>
<p>複数の所有者が同じデータを共有する場合に使用。シングルスレッド専用。</p>
<pre>
use std::rc::Rc;

fn main() {
    let a = Rc::new(5);
    println!("count after a: {}", Rc::strong_count(&amp;a));  // 1

    let b = Rc::clone(&amp;a);  // 参照カウント増加
    println!("count after b: {}", Rc::strong_count(&amp;a));  // 2

    {
        let c = Rc::clone(&amp;a);
        println!("count after c: {}", Rc::strong_count(&amp;a));  // 3
    }  // cがドロップ

    println!("count after c drops: {}", Rc::strong_count(&amp;a));  // 2
}
</pre>

<h2>グラフ構造での使用例</h2>
<pre>
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    children: Vec&lt;Rc&lt;Node&gt;&gt;,
}

fn main() {
    // 共有ノード
    let shared = Rc::new(Node {
        value: 3,
        children: vec![],
    });

    let node1 = Rc::new(Node {
        value: 1,
        children: vec![Rc::clone(&amp;shared)],
    });

    let node2 = Rc::new(Node {
        value: 2,
        children: vec![Rc::clone(&amp;shared)],
    });

    // sharedは3つの参照（オリジナル + node1 + node2）
    println!("shared count: {}", Rc::strong_count(&amp;shared));  // 3
}
</pre>

<h2>Rc::clone vs .clone()</h2>
<pre>
use std::rc::Rc;

fn main() {
    let a = Rc::new(String::from("hello"));

    // Rc::clone(): 参照カウント増加（高速）
    let b = Rc::clone(&amp;a);

    // a.clone()も同じ（Rcに対してはRc::cloneが呼ばれる）
    let c = a.clone();

    // 慣例的にRc::clone()を使うことで、深いコピーではないことを明示
}
</pre>

<h2>Arc&lt;T&gt;（Atomic Reference Counted）</h2>
<p>スレッド間で共有する場合に使用。アトミック操作でスレッドセーフ。</p>
<pre>
use std::sync::Arc;
use std::thread;

fn main() {
    let data = Arc::new(vec![1, 2, 3, 4, 5]);

    let mut handles = vec![];

    for i in 0..3 {
        let data = Arc::clone(&amp;data);  // 各スレッドで共有
        let handle = thread::spawn(move || {
            println!("Thread {}: {:?}", i, data);
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
</pre>

<h2>RcとArcの使い分け</h2>
<ul>
    <li><strong>Rc</strong>: シングルスレッド、パフォーマンス重視</li>
    <li><strong>Arc</strong>: マルチスレッド、スレッドセーフが必要</li>
</ul>

<h2>内部可変性（RefCellと組み合わせ）</h2>
<p>Rcは不変参照のみ提供。可変性が必要な場合はRefCellと組み合わせる。</p>
<pre>
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    // Rc&lt;RefCell&lt;T&gt;&gt;で共有しつつ可変に
    let data = Rc::new(RefCell::new(5));

    let a = Rc::clone(&amp;data);
    let b = Rc::clone(&amp;data);

    // 可変借用
    *a.borrow_mut() += 10;
    println!("a: {}", a.borrow());  // 15

    *b.borrow_mut() += 5;
    println!("b: {}", b.borrow());  // 20

    println!("data: {}", data.borrow());  // 20
}
</pre>

<h2>循環参照の問題</h2>
<pre>
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    next: RefCell&lt;Option&lt;Rc&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let a = Rc::new(Node {
        value: 1,
        next: RefCell::new(None),
    });

    let b = Rc::new(Node {
        value: 2,
        next: RefCell::new(Some(Rc::clone(&amp;a))),
    });

    // 循環参照を作成（メモリリーク！）
    *a.next.borrow_mut() = Some(Rc::clone(&amp;b));

    // 参照カウントは両方2のまま、解放されない
    println!("a count: {}", Rc::strong_count(&amp;a));
    println!("b count: {}", Rc::strong_count(&amp;b));
}
</pre>

<h2>Weak&lt;T&gt;で循環参照を回避</h2>
<pre>
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,    // 親への弱い参照
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    // leafの親をbranchに設定（弱い参照）
    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    // 弱い参照からRcを取得
    if let Some(parent) = leaf.parent.borrow().upgrade() {
        println!("leaf's parent: {}", parent.value);
    }

    println!("branch strong: {}", Rc::strong_count(&amp;branch));  // 1
    println!("branch weak: {}", Rc::weak_count(&amp;branch));      // 1
}
</pre>

<h2>ArcとMutex</h2>
<pre>
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());  // 10
}
</pre>

<h2>エクササイズ 7.2</h2>
<ol>
    <li>Rcを使って、複数のリストが末尾を共有する構造を作成</li>
    <li>Weakを使って、双方向リンクリストの親参照を実装</li>
</ol>

<h3>解答例</h3>
<pre>
// 1. 末尾を共有するリスト
use std::rc::Rc;

enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    // 共有される末尾
    let shared_tail = Rc::new(Cons(10, Rc::new(Cons(20, Rc::new(Nil)))));

    // 2つのリストが同じ末尾を共有
    let list1 = Cons(1, Rc::clone(&amp;shared_tail));
    let list2 = Cons(2, Rc::clone(&amp;shared_tail));

    println!("shared_tail count: {}", Rc::strong_count(&amp;shared_tail));  // 3
}

// 2. 双方向リンクリスト（簡易版）
use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct BiNode {
    value: i32,
    prev: RefCell&lt;Weak&lt;BiNode&gt;&gt;,
    next: RefCell&lt;Option&lt;Rc&lt;BiNode&gt;&gt;&gt;,
}

impl BiNode {
    fn new(value: i32) -&gt; Rc&lt;Self&gt; {
        Rc::new(BiNode {
            value,
            prev: RefCell::new(Weak::new()),
            next: RefCell::new(None),
        })
    }
}

fn main() {
    let node1 = BiNode::new(1);
    let node2 = BiNode::new(2);
    let node3 = BiNode::new(3);

    // node1 -> node2 -> node3
    *node1.next.borrow_mut() = Some(Rc::clone(&amp;node2));
    *node2.next.borrow_mut() = Some(Rc::clone(&amp;node3));

    // node1 <- node2 <- node3（弱い参照）
    *node2.prev.borrow_mut() = Rc::downgrade(&amp;node1);
    *node3.prev.borrow_mut() = Rc::downgrade(&amp;node2);

    // 前後への移動
    println!("node2.next: {:?}", node2.next.borrow().as_ref().map(|n| n.value));
    println!("node2.prev: {:?}", node2.prev.borrow().upgrade().map(|n| n.value));
}
</pre>

<hr>
<p><a href="ch07_01_box.html">&lt;&lt; 前へ</a> | <a href="index.html">目次</a> | <a href="ch07_03_static.html">次へ: 7.3 static変数と定数 &gt;&gt;</a></p>
</body>
</html>
