<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>4.1 所有権の基本 - Rust入門</title>
</head>
<body>
<p><a href="index.html">目次に戻る</a></p>
<h1>4.1 所有権の基本【Rust最重要概念】</h1>

<h2>なぜ所有権が必要なのか</h2>
<p>C++/Kotlinとの比較：</p>
<table border="1" cellpadding="5">
<tr><th>言語</th><th>メモリ管理</th><th>問題点</th></tr>
<tr><td>C++</td><td>手動（new/delete）またはRAII</td><td>メモリリーク、二重解放、ダングリングポインタ</td></tr>
<tr><td>Kotlin/Java</td><td>GC（ガベージコレクション）</td><td>パフォーマンスの予測不能、メモリ使用量</td></tr>
<tr><td>Rust</td><td>所有権システム（コンパイル時検査）</td><td>学習コスト（利点は安全性と性能の両立）</td></tr>
</table>

<h2>所有権の3つのルール</h2>
<ol>
    <li>Rustの各値は<strong>所有者（owner）</strong>と呼ばれる変数を持つ</li>
    <li>所有者は<strong>常に1つ</strong>だけ</li>
    <li>所有者がスコープから外れると、値は<strong>ドロップ（破棄）</strong>される</li>
</ol>

<h2>スコープとドロップ</h2>
<pre>
fn main() {
    {
        let s = String::from("hello");  // sがスコープに入る
        println!("{}", s);
    }  // sがスコープを抜ける → メモリが自動的に解放される

    // println!("{}", s);  // エラー: sは存在しない
}
</pre>

<h2>ムーブ（Move）</h2>
<p>ヒープに確保されるデータは、代入時に<strong>ムーブ</strong>される（所有権が移動する）。</p>
<pre>
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;  // s1の所有権がs2にムーブされる

    // println!("{}", s1);  // エラー: s1はもう使えない
    println!("{}", s2);     // OK
}
</pre>

<h2>C++との違い</h2>
<pre>
// C++の場合（浅いコピー、二重解放の危険）
std::string s1 = "hello";
std::string s2 = s1;  // コピー（両方有効）

// Rustの場合（ムーブ、安全）
let s1 = String::from("hello");
let s2 = s1;  // ムーブ（s1は無効化）
</pre>

<h2>スタックのデータはコピー</h2>
<p>整数などスタックに確保されるデータは<strong>コピー</strong>される（Copyトレイト）。</p>
<pre>
fn main() {
    let x = 5;
    let y = x;  // コピー（xもyも有効）

    println!("x = {}, y = {}", x, y);  // 両方使える
}
</pre>

<h3>Copyトレイトを持つ型</h3>
<ul>
    <li>整数型（i32, u64など）</li>
    <li>浮動小数点型（f32, f64）</li>
    <li>bool</li>
    <li>char</li>
    <li>Copyトレイトを持つ型のみで構成されるタプル</li>
</ul>

<h2>関数とムーブ</h2>
<pre>
fn takes_ownership(s: String) {
    println!("{}", s);
}  // sはここでドロップされる

fn makes_copy(x: i32) {
    println!("{}", x);
}  // xはコピーなので、元の変数は影響を受けない

fn main() {
    let s = String::from("hello");
    takes_ownership(s);
    // println!("{}", s);  // エラー: sはムーブされた

    let x = 5;
    makes_copy(x);
    println!("{}", x);  // OK: xはコピーされた
}
</pre>

<h2>戻り値と所有権</h2>
<pre>
fn gives_ownership() -&gt; String {
    let s = String::from("hello");
    s  // 所有権が呼び出し元に移動
}

fn takes_and_gives_back(s: String) -&gt; String {
    s  // そのまま返す
}

fn main() {
    let s1 = gives_ownership();        // s1が所有権を得る
    println!("{}", s1);

    let s2 = String::from("hello");
    let s3 = takes_and_gives_back(s2); // s2はムーブ、s3が所有権を得る
    // println!("{}", s2);  // エラー: s2はムーブされた
    println!("{}", s3);     // OK
}
</pre>

<h2>Clone（明示的なコピー）</h2>
<pre>
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();  // ディープコピー（両方有効）

    println!("s1 = {}, s2 = {}", s1, s2);
}
</pre>
<p>注意：cloneは高コストな操作（ヒープメモリを複製）。必要な場合のみ使用。</p>

<h2>構造体と所有権</h2>
<pre>
struct User {
    name: String,
    age: u32,
}

fn main() {
    let user1 = User {
        name: String::from("Taro"),
        age: 25,
    };

    let user2 = user1;  // user1全体がムーブ
    // println!("{}", user1.name);  // エラー

    // 一部だけムーブすることも
    let user3 = User {
        name: String::from("Jiro"),
        age: 30,
    };
    let name = user3.name;  // nameだけムーブ
    println!("age: {}", user3.age);  // ageは使える
    // println!("name: {}", user3.name);  // エラー: nameはムーブされた
}
</pre>

<h2>エクササイズ 4.1</h2>
<ol>
    <li>以下のコードがコンパイルエラーになる理由を説明し、修正してください：
<pre>
fn main() {
    let s = String::from("hello");
    let len = calculate_length(s);
    println!("'{}' has length {}", s, len);
}

fn calculate_length(s: String) -&gt; usize {
    s.len()
}
</pre>
    </li>
    <li>Vecを関数に渡した後も使い続けたい場合、どうすればよいか</li>
</ol>

<h3>解答例</h3>
<pre>
// 1. 修正方法1: 所有権を返す
fn calculate_length(s: String) -&gt; (String, usize) {
    let len = s.len();
    (s, len)
}

fn main() {
    let s = String::from("hello");
    let (s, len) = calculate_length(s);
    println!("'{}' has length {}", s, len);
}

// 1. 修正方法2: 参照を使う（次のセクションで詳しく）
fn calculate_length_ref(s: &amp;String) -&gt; usize {
    s.len()
}

fn main() {
    let s = String::from("hello");
    let len = calculate_length_ref(&amp;s);
    println!("'{}' has length {}", s, len);
}

// 2. Vecの場合も同様
fn process_vec(v: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    v.iter().sum()
}

fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let sum = process_vec(&amp;v);
    println!("v = {:?}, sum = {}", v, sum);
}
</pre>

<hr>
<p><a href="ch03_04_hashmap.html">&lt;&lt; 前へ</a> | <a href="index.html">目次</a> | <a href="ch04_02_borrowing.html">次へ: 4.2 参照と借用 &gt;&gt;</a></p>
</body>
</html>
